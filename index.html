<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ArenaRush+ — improved AI, graphics & multiplayer (experimental)</title>
<style>
  :root{
    --bg1:#e6f6ff; --panel:#fff; --accent:#1e88ff; --danger:#ff5c5c; --muted:#546677;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg1),#f7fbff);}
  #root{max-width:1200px;margin:10px auto;padding:10px;box-sizing:border-box;}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  h1{font-size:18px;margin:0}
  .panel{background:var(--panel);border-radius:10px;padding:10px;box-shadow:0 6px 18px rgba(15,40,80,0.06)}
  #gameRow{display:flex;gap:12px}
  #boardWrap{flex:1}
  canvas{width:100%;height:640px;display:block;border-radius:8px;background:linear-gradient(180deg,#cdeeff,#9fd8ff)}
  #sidebar{width:340px;min-width:260px}
  .elixirBar{height:26px;background:#e6f2ff;border-radius:999px;position:relative;overflow:hidden;border:1px solid rgba(0,0,0,0.04)}
  .elixirFill{height:100%;width:0%;background:linear-gradient(90deg,#6fb4ff,#1e88ff);transition:width 120ms linear}
  .elixirText{position:absolute;left:10px;top:0;bottom:0;display:flex;align-items:center;font-weight:700;color:#fff;text-shadow:0 1px 0 rgba(0,0,0,0.25)}
  .cards{display:flex;gap:8px;margin-top:10px}
  .card{flex:1;padding:8px;border-radius:8px;background:linear-gradient(#fff,#f6fbff);border:1px solid rgba(6,30,60,0.04);text-align:center;cursor:pointer;user-select:none}
  .card .name{font-weight:700}
  .card .cost{font-size:13px;color:var(--muted)}
  .card.selected{box-shadow:0 8px 22px rgba(30,136,255,0.12);outline:2px solid rgba(30,136,255,0.12)}
  .meta{display:flex;justify-content:space-between;margin-top:8px;color:var(--muted);font-size:13px}
  button{background:var(--accent);color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  .center{display:flex;align-items:center;justify-content:center}
  .modeRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  textarea{width:100%;height:120px;font-family:monospace;resize:vertical}
  @media (max-width:900px){#gameRow{flex-direction:column-reverse} canvas{height:520px}}
</style>
</head>
<body>
<div id="root">
  <header>
    <div>
      <h1>ArenaRush+ — Improved AI, Graphics & Multiplayer</h1>
      <div class="small">Modes: Vs AI — Local 2P — Online P2P (manual signaling)</div>
    </div>
    <div class="center" style="gap:8px">
      <div class="panel small center" style="padding:8px 12px;">
        Time: <strong id="timeText" style="margin-left:6px">03:00</strong>
      </div>
      <button id="restartBtn">Restart</button>
    </div>
  </header>

  <div id="gameRow">
    <div id="boardWrap" class="panel">
      <canvas id="board"></canvas>
    </div>

    <aside id="sidebar" class="panel">
      <div style="margin-bottom:10px">
        <div class="elixirBar" title="Elixir">
          <div class="elixirFill" id="elixirFill"></div>
          <div class="elixirText" id="elixirText">0 / 10</div>
        </div>
      </div>

      <div>
        <div class="small">Mode</div>
        <div class="modeRow">
          <button id="modeAi">Play vs AI</button>
          <button id="modeLocal">Local 2P</button>
          <button id="modeP2P">Online P2P</button>
        </div>
      </div>

      <div style="margin-top:10px">
        <div class="small">Deck</div>
        <div class="cards" id="cards"></div>
      </div>

      <div style="margin-top:12px" class="meta">
        <div>Player Towers: <span id="playerTowers">3</span></div>
        <div>Enemy Towers: <span id="enemyTowers">3</span></div>
      </div>

      <div style="margin-top:12px" class="small">Controls: select a card, then click/tap your half to deploy. For local 2P, left side = player1, right side = player2 (hotseat).</div>

      <div style="margin-top:12px" class="small">Online P2P signaling (manual):</div>
      <div style="margin-top:8px" class="small">1) Click <em>Create Offer</em>, copy offer text and send to opponent. 2) Opponent pastes offer in their box and clicks <em>Accept Offer</em>, then sends you the answer. 3) Paste answer here and click <em>Accept Answer</em>.</div>

      <div style="margin-top:8px">
        <div><button id="createOfferBtn">Create Offer</button> <button id="acceptOfferBtn">Accept Offer</button></div>
        <textarea id="offerBox" placeholder="Paste remote offer/answer here..."></textarea>
        <div style="margin-top:6px" class="center"><button id="acceptAnswerBtn" style="background:#8899ff">Accept Answer</button></div>
      </div>

    </aside>
  </div>
</div>

<script>
/* ArenaRush+ — single-file enhanced game
   - Slower troops
   - Troops stop and attack towers/enemies
   - Improved AI logic
   - Procedural graphics (no external assets)
   - Multiplayer:
     * Local 2P (same device)
     * Peer-to-peer via WebRTC DataChannel with manual copy/paste signaling (no server)
*/

// ---------- Canvas and DPI ----------
const canvas = document.getElementById('board'), ctx = canvas.getContext('2d');
const LOGICAL_W = 900, LOGICAL_H = 600;
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);
function cssToGame(cx, cy){
  const rect = canvas.getBoundingClientRect();
  return { x: (cx - rect.left) * (LOGICAL_W / rect.width), y: (cy - rect.top) * (LOGICAL_H / rect.height) };
}
resizeCanvas();

// ---------- State ----------
const MAX_ELIXIR = 10, MATCH_TIME = 180;
let state = {
  running:true, timeLeft:MATCH_TIME, elixir:5, selectedCardIdx:null,
  entities:[], towers:{player:[], enemy:[]}, lastTS:performance.now(), aiTimer:1.4, result:null,
  mode:'ai', // 'ai' | 'local' | 'p2p-host' | 'p2p-guest'
  p2p: { pc:null, dc:null, isHost:false }
};

// ---------- Sound ----------
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function beep(freq=440, t=0.06, g=0.02){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator(); const gg = audioCtx.createGain();
  o.type = 'sine'; o.frequency.value = freq; gg.gain.value = g;
  o.connect(gg); gg.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + t);
}

// ---------- Cards & units ----------
const CARD_POOL = [
  { id:'spear', name:'Pike', cost:1, hp:90, dmg:12, speed:60, radius:8, color:'#ffd27f' },
  { id:'arch', name:'Marksman', cost:2, hp:110, dmg:18, speed:72, radius:9, color:'#8ae6a1' },
  { id:'guard', name:'Shield', cost:3, hp:360, dmg:30, speed:36, radius:16, color:'#d8a78f' },
  { id:'coloss', name:'Bulwark', cost:5, hp:950, dmg:45, speed:24, radius:22, color:'#ef8b8b' }
];
let hand = [];
function buildHand(){
  hand = [];
  for(let i=0;i<4;i++) hand.push(CARD_POOL[Math.floor(Math.random()*CARD_POOL.length)]);
}

// ---------- Towers ----------
function resetTowers(){
  const leftX = LOGICAL_W * 0.14, rightX = LOGICAL_W * 0.86;
  state.towers.player = [
    {id:'p-main', x:leftX, y:LOGICAL_H*0.5, hp:1400, maxHp:1400, main:true},
    {id:'p-top',  x:leftX+LOGICAL_W*0.10, y:LOGICAL_H*0.24, hp:900, maxHp:900},
    {id:'p-bot',  x:leftX+LOGICAL_W*0.10, y:LOGICAL_H*0.76, hp:900, maxHp:900}
  ];
  state.towers.enemy = [
    {id:'e-main', x:rightX, y:LOGICAL_H*0.5, hp:1400, maxHp:1400, main:true},
    {id:'e-top',  x:rightX-LOGICAL_W*0.10, y:LOGICAL_H*0.24, hp:900, maxHp:900},
    {id:'e-bot',  x:rightX-LOGICAL_W*0.10, y:LOGICAL_H*0.76, hp:900, maxHp:900}
  ];
}

// ---------- Entities ----------
/* troop: { kind:'troop', owner:'player'|'enemy', x,y, vx, hp, dmg, radius, speed, color, target, attackCooldown } */
function spawnTroop(owner, cardIdx, x, y){
  const base = hand[cardIdx] || CARD_POOL[cardIdx];
  const dir = owner==='player' ? 1 : -1;
  const troop = {
    kind:'troop', owner, x, y,
    vx: dir * base.speed/60, speed:base.speed, hp:base.hp, maxHp:base.hp,
    dmg: base.dmg, radius: base.radius, color: base.color,
    typeId: base.id, attackCooldown: 0
  };
  state.entities.push(troop);
  beep(520 + Math.random()*80, 0.06, 0.03);
}

// ---------- Targeting ----------
function nearestEnemyFor(troop){
  let best=null, bd=Infinity;
  state.entities.forEach(e=>{
    if(e.kind==='troop' && e.owner !== troop.owner){
      const d = dist(troop, e);
      if(d < bd){ bd=d; best=e; }
    }
  });
  const towersArr = troop.owner==='player' ? state.towers.enemy : state.towers.player;
  towersArr.forEach(t=>{
    if(t.hp>0){
      const d = Math.hypot(t.x - troop.x, t.y - troop.y);
      if(d < bd){ bd=d; best=t; }
    }
  });
  return best;
}

// ---------- Utils ----------
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rnd(a,b){ return Math.random()*(b-a)+a; }

// ---------- AI Improvements ----------
function aiChooseAndDeploy(){
  // smarter: if player has low towers -> commit to that side; else choose based on elixir and current entities
  const isPlayerWeak = state.towers.player.reduce((s,t)=>s+t.hp,0) < state.towers.enemy.reduce((s,t)=>s+t.hp,0);
  const affordableIdxs = hand.map((c,i)=>({c,i})).filter(ci=>ci.c.cost <= Math.floor(state.elixir + 0.5));
  if(affordableIdxs.length===0) return;
  // bias toward heavier unit if player is weak or near end of match
  const heavyBias = (isPlayerWeak || state.timeLeft<40) ? 1.25 : 1.0;
  const weights = affordableIdxs.map(ai=>{
    let w = 1;
    w += ai.c.cost * 0.4 * heavyBias;
    // if enemy towers count low, favor medium troops
    return {i:ai.i, w};
  });
  // pick by weight
  const totalW = weights.reduce((s,x)=>s+x.w,0);
  let r = Math.random()*totalW;
  let pick = weights[0].i;
  for(const w of weights){ if(r < w.w){ pick = w.i; break; } r -= w.w; }
  // choose lane by evaluating nearest weak tower
  const enemyTowers = state.towers.enemy;
  if(enemyTowers.length===0) return;
  // prefer main if it's vulnerable
  enemyTowers.sort((a,b)=>a.hp - b.hp);
  const target = enemyTowers[0];
  // map target to lane Y roughly
  let spawnY = target.y + rnd(-18,18);
  // spawn on right side (AI)
  spawnTroop('enemy', pick, LOGICAL_W*0.86 - 18 + rnd(-8,8), spawnY);
  // consume a small conceptual elixir for AI pacing (doesn't reduce player's elixir)
}

// ---------- Game loop: movement + stop-and-attack ----------
function update(dt){
  if(!state.running) return;
  state.timeLeft -= dt;
  if(state.timeLeft <= 0){ state.timeLeft = 0; finishByTime(); }
  state.elixir = clamp(state.elixir + 1*dt, 0, MAX_ELIXIR);

  // AI deploy pacing
  if(state.mode === 'ai'){
    state.aiTimer -= dt;
    if(state.aiTimer <= 0){
      state.aiTimer = 1.2 + Math.random()*1.8;
      aiChooseAndDeploy();
    }
  } else if(state.mode === 'p2p-host' || state.mode === 'p2p-guest'){
    // networked: actions come via DataChannel; no local AI
  } else if(state.mode === 'local'){
    // you might optionally have a soft AI for player2 if wanted; here local is purely human
  }

  // update troops
  for(let i = state.entities.length - 1; i >= 0; i--){
    const e = state.entities[i];
    if(e.kind === 'troop'){
      // choose target
      if(!e.target || (e.target.hp !== undefined && e.target.hp <= 0)) e.target = nearestEnemyFor(e);

      if(e.target){
        // if target is close enough -> stop moving and attack
        const targetXY = { x: e.target.x, y: e.target.y };
        const d = Math.hypot(targetXY.x - e.x, targetXY.y - e.y);
        const reach = e.radius + (e.target.radius || 20) + 6;
        if(d <= reach){
          // attack
          e.attackCooldown -= dt;
          if(e.attackCooldown <= 0){
            // deal damage
            const dmg = e.dmg;
            if(e.target.hp !== undefined){
              e.target.hp -= dmg;
              // small hit effect
              state.entities.push({kind:'effect', x:e.target.x + rnd(-6,6), y:e.target.y + rnd(-6,6), life:0.18, type:'hit'});
              beep(220 + Math.random()*120, 0.04, 0.02);
            }
            e.attackCooldown = 0.7 - clamp(e.speed/200,0,0.4); // faster troops attack a little faster
          }
          // small shaking animation: do not move
        } else {
          // move toward target or forward if none
          const dir = e.owner==='player' ? 1 : -1;
          // move fractionally per dt (slower troops)
          const move = e.speed * 0.4 * dt; // slowed globally by 0.4 factor
          e.x += dir * move;
        }
      } else {
        // no target, move forward slowly
        const move = e.speed * 0.35 * dt;
        const dir = e.owner==='player' ? 1 : -1;
        e.x += dir * move;
      }

      if(e.hp <= 0){ state.entities.splice(i,1); continue; }
      if(e.x < -60 || e.x > LOGICAL_W + 60) state.entities.splice(i,1);
    } else if(e.kind === 'proj'){
      e.x += e.vx * dt * 60; e.y += e.vy * dt * 60; e.life -= 1;
      for(let j=state.entities.length-1;j>=0;j--){
        const t = state.entities[j];
        if(t.kind==='troop' && t.owner !== e.owner){
          if(Math.hypot(t.x-e.x, t.y-e.y) <= t.radius + e.radius){
            t.hp -= e.dmg; e.life = 0;
            state.entities.push({kind:'effect', x:e.x, y:e.y, life:0.14, type:'hit'});
            break;
          }
        }
      }
      if(e.life <= 0) state.entities.splice(i,1);
    } else if(e.kind === 'effect'){
      e.life -= dt;
      if(e.life <= 0) state.entities.splice(i,1);
    }
  }

  // damage from troops may have killed towers
  state.towers.player = state.towers.player.filter(t => t.hp > 0);
  state.towers.enemy  = state.towers.enemy.filter(t => t.hp > 0);

  if(state.towers.enemy.length === 0){ state.running = false; state.result='YOU WIN'; }
  if(state.towers.player.length === 0){ state.running = false; state.result='YOU LOSE'; }

  updateUI();
}

// finish by time
function finishByTime(){
  const p = state.towers.player.reduce((s,t)=>s + Math.max(0,t.hp),0);
  const e = state.towers.enemy.reduce((s,t)=>s + Math.max(0,t.hp),0);
  state.result = (p>e) ? 'TIME WIN' : (p<e ? 'TIME LOSE' : 'DRAW');
  state.running = false;
}

// ---------- Drawing (procedural sprites) ----------
function draw(){
  // background
  ctx.clearRect(0,0,LOGICAL_W,LOGICAL_H);
  ctx.fillStyle = '#cfefff'; ctx.fillRect(0,0,LOGICAL_W,LOGICAL_H);

  // river
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillRect(LOGICAL_W*0.445,0, LOGICAL_W*0.11, LOGICAL_H);

  // center line
  ctx.beginPath(); ctx.moveTo(LOGICAL_W*0.5,0); ctx.lineTo(LOGICAL_W*0.5,LOGICAL_H); ctx.strokeStyle='rgba(20,40,80,0.06)'; ctx.lineWidth=2; ctx.stroke();

  // draw towers
  function drawTower(t, isPlayer){
    ctx.save(); ctx.translate(t.x,t.y);
    ctx.beginPath(); ctx.fillStyle = isPlayer ? '#2f6fb3' : '#b33a3a'; ctx.arc(0,0,28,0,Math.PI*2); ctx.fill();
    // badge
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.fillText(Math.max(0,Math.round(t.hp)),0,6);
    // hp bar
    const w = 56, h = 8; ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(-w/2,36,w,h);
    const frac = clamp(t.hp / t.maxHp,0,1);
    ctx.fillStyle = isPlayer ? '#68a7ff' : '#ff8b8b'; ctx.fillRect(-w/2,36,w*frac,h);
    ctx.restore();
  }
  state.towers.player.forEach(t=>drawTower(t,true));
  state.towers.enemy.forEach(t=>drawTower(t,false));

  // draw entities
  state.entities.forEach(e=>{
    if(e.kind === 'troop'){
      // draw shadow
      ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.ellipse(e.x, e.y + e.radius + 4, e.radius*1.1, e.radius*0.5, 0,0,Math.PI*2); ctx.fill();
      // body
      ctx.beginPath(); ctx.fillStyle = e.color; ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
      // small helmet/face graphic
      ctx.fillStyle='rgba(0,0,0,0.11)'; ctx.fillRect(e.x - e.radius*0.6, e.y - e.radius*0.45, e.radius*1.2, e.radius*0.4);
      // hp text
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.font='10px sans-serif'; ctx.textAlign='center'; ctx.fillText(Math.max(0, Math.round(e.hp)), e.x, e.y+3);
    } else if(e.kind === 'proj'){
      ctx.beginPath(); ctx.fillStyle='#222'; ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill();
    } else if(e.kind === 'effect'){
      const a = clamp(e.life / 0.18, 0, 1);
      if(e.type === 'hit'){
        ctx.beginPath(); ctx.fillStyle = `rgba(255,220,120,${a})`; ctx.arc(e.x,e.y,6 + (0.6 - a)*8,0,Math.PI*2); ctx.fill();
      }
    }
  });

  // overlay when ended
  if(!state.running && state.result){
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0, LOGICAL_H*0.35, LOGICAL_W, LOGICAL_H*0.3);
    ctx.fillStyle='#fff'; ctx.font='44px sans-serif'; ctx.textAlign='center'; ctx.fillText(state.result, LOGICAL_W/2, LOGICAL_H*0.53);
    ctx.font='16px sans-serif'; ctx.fillText('Press Restart to play again', LOGICAL_W/2, LOGICAL_H*0.62);
  }

  // debug small stats
  if(state.debug){
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(10,10,260,92);
    ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.textAlign='left';
    ctx.fillText(`entities: ${state.entities.length}`, 18, 30);
    ctx.fillText(`elixir: ${state.elixir.toFixed(2)}`, 18, 48);
    ctx.fillText(`time: ${Math.ceil(state.timeLeft)}s`, 18, 66);
    ctx.fillText(`mode: ${state.mode}`, 18, 84);
    ctx.restore();
  }
}

// ---------- UI binding ----------
const elixirFill = document.getElementById('elixirFill');
const elixirText = document.getElementById('elixirText');
const cardsDiv = document.getElementById('cards');
const timeText = document.getElementById('timeText');
const restartBtn = document.getElementById('restartBtn');
const playerTowersEl = document.getElementById('playerTowers');
const enemyTowersEl = document.getElementById('enemyTowers');

function updateUI(){
  elixirFill.style.width = (state.elixir / MAX_ELIXIR * 100) + '%';
  elixirText.textContent = `${Math.floor(state.elixir)} / ${MAX_ELIXIR}`;
  const m = Math.floor(state.timeLeft / 60), s = Math.floor(state.timeLeft % 60);
  timeText.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  playerTowersEl.textContent = state.towers.player.length;
  enemyTowersEl.textContent = state.towers.enemy.length;
  Array.from(cardsDiv.children).forEach((ch, idx) => ch.classList.toggle('selected', state.selectedCardIdx === idx));
}

// render hand
function renderHand(){
  cardsDiv.innerHTML = '';
  hand.forEach((c, idx) => {
    const el = document.createElement('div');
    el.className='card';
    el.innerHTML = `<div class="name">${c.name}</div><div class="cost">${c.cost} elixir</div>`;
    el.addEventListener('click', () => {
      if(state.selectedCardIdx === idx) state.selectedCardIdx = null; else state.selectedCardIdx = idx;
      updateUI();
    });
    cardsDiv.appendChild(el);
  });
}

// ---------- Input ----------
canvas.addEventListener('click', (ev) => {
  if(!state.running) return;
  // enable audio context on first user gesture
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

  const p = cssToGame(ev.clientX, ev.clientY);
  // in local mode: allow both players by side
  if(state.mode === 'local'){
    // if clicked left half -> player, else player2
    const side = (p.x <= LOGICAL_W*0.5) ? 'player' : 'enemy';
    // choose the hand index to use for that side: for simplicity we let both players use same hand indexes but caller should manage
    if(state.selectedCardIdx === null) return;
    const c = hand[state.selectedCardIdx];
    if(c.cost > Math.floor(state.elixir) && side === 'player'){
      beep(260,0.06,0.02); return;
    }
    // local second player uses same elixir pool? to keep it simple: right-side uses AI-like free deploy but costs nothing locally
    if(side === 'player'){
      // player's deploy
      if(p.x > LOGICAL_W*0.5) return;
      spawnTroop('player', state.selectedCardIdx, Math.max(40, p.x), p.y);
      state.elixir -= c.cost;
    } else {
      // local second player on right
      spawnTroop('enemy', state.selectedCardIdx, Math.min(LOGICAL_W-40, p.x), p.y);
    }
    state.selectedCardIdx = null;
    updateUI();
    return;
  }

  // in p2p modes, only allow deploy if you're the local player (we treat local as player)
  if(state.mode === 'p2p-host' || state.mode === 'p2p-guest'){
    // We will send deploy messages to remote peer via DataChannel and also apply locally
    if(state.selectedCardIdx === null) return;
    const c = hand[state.selectedCardIdx];
    if(c.cost > Math.floor(state.elixir)){
      beep(260,0.06,0.02); return;
    }
    // Only allow deploying on your side of board
    if(p.x > LOGICAL_W*0.5) { beep(220,0.04,0.02); return; }
    spawnTroop('player', state.selectedCardIdx, Math.max(40, p.x), p.y);
    // send a "deploy" to remote so they can spawn a mirrored troop as enemy
    const msg = {type:'deploy', cardIdx: state.selectedCardIdx, y: p.y};
    sendP2PMessage(msg);
    state.elixir -= c.cost;
    state.selectedCardIdx = null;
    updateUI();
    return;
  }

  // normal AI mode
  if(state.selectedCardIdx === null) return;
  const chosen = hand[state.selectedCardIdx];
  if(chosen.cost > Math.floor(state.elixir)){ beep(260,0.06,0.02); return; }
  if(p.x > LOGICAL_W*0.5) { beep(220,0.04,0.02); return; }
  // snap to lane
  const lanes = [LOGICAL_H*0.5, LOGICAL_H*0.24, LOGICAL_H*0.76];
  let laneY = lanes.reduce((prev,curr)=> Math.abs(curr-p.y) < Math.abs(prev-p.y) ? curr : prev);
  spawnTroop('player', state.selectedCardIdx, Math.max(40, p.x), laneY + rnd(-12,12));
  state.elixir -= chosen.cost;
  state.selectedCardIdx = null;
  updateUI();
});

// ---------- Multiplayer (P2P via manual signaling) ----------
const createOfferBtn = document.getElementById('createOfferBtn');
const acceptOfferBtn = document.getElementById('acceptOfferBtn');
const offerBox = document.getElementById('offerBox');
const acceptAnswerBtn = document.getElementById('acceptAnswerBtn');

function logP2P(msg){ console.log('[P2P]', msg); }

function setupPeerConnection(isHost){
  const pc = new RTCPeerConnection();
  const dc = pc.createDataChannel('gamedata');
  state.p2p = { pc, dc, isHost };
  dc.onopen = ()=>{ logP2P('DataChannel open'); beep(800,0.06,0.03); };
  dc.onmessage = (ev)=>{ handleP2PMessage(ev.data); };
  pc.ondatachannel = (ev)=>{ const ch = ev.channel; ch.onmessage = (e)=> handleP2PMessage(e.data); ch.onopen=()=>logP2P('remote channel open'); state.p2p.dc = ch; };

  pc.onicecandidate = (ev)=> {
    if(ev.candidate) return; // we will wait until localDescription is complete before showing
  };

  // remote deploy messages will be handled
  return {pc, dc};
}

async function createOffer(){
  const {pc, dc} = setupPeerConnection(true);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // Wait for ICE gathering to finish (or short-circuit)
  await waitForIceGatheringComplete(pc);
  offerBox.value = JSON.stringify(pc.localDescription);
  state.mode = 'p2p-host';
  state.p2p.isHost = true;
  renderModeButtons();
  logP2P('Offer created — copy text and send to opponent.');
}

async function acceptOffer(){
  // receive remote offer (paste it into offerBox)
  let remote = null;
  try { remote = JSON.parse(offerBox.value); } catch(e){ alert('Invalid offer JSON'); return; }
  const pc = new RTCPeerConnection();
  pc.ondatachannel = ev => {
    const ch = ev.channel; ch.onmessage = (e)=> handleP2PMessage(e.data);
    ch.onopen = ()=>{ logP2P('Datachannel open (guest)'); beep(760,0.06,0.03); state.p2p.dc = ch; };
  };
  pc.onicecandidate = ()=> {};
  await pc.setRemoteDescription(remote);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await waitForIceGatheringComplete(pc);
  offerBox.value = JSON.stringify(pc.localDescription); // the guest puts the answer in the box to send back
  state.mode = 'p2p-guest';
  state.p2p.pc = pc;
  renderModeButtons();
  logP2P('Answer created — copy answer and send back to host.');
}

async function acceptAnswer(){
  // host pastes remote answer here
  if(!state.p2p || !state.p2p.pc) { alert('No peer connection in host mode. Create Offer first.'); return; }
  let remote = null;
  try { remote = JSON.parse(offerBox.value); } catch(e){ alert('Invalid answer JSON'); return; }
  await state.p2p.pc.setRemoteDescription(remote);
  logP2P('Remote answer accepted. P2P should connect shortly.');
}

function waitForIceGatheringComplete(pc){
  return new Promise(resolve => {
    if(pc.iceGatheringState === 'complete') resolve();
    function check(){
      if(pc.iceGatheringState === 'complete'){ pc.removeEventListener('icegatheringstatechange', check); resolve(); }
    }
    pc.addEventListener('icegatheringstatechange', check);
    // fallback timeout
    setTimeout(() => resolve(), 3000);
  });
}

function sendP2PMessage(obj){
  try {
    const str = JSON.stringify(obj);
    if(state.p2p && state.p2p.dc && state.p2p.dc.readyState === 'open'){
      state.p2p.dc.send(str);
    }
  } catch(e){ console.warn('p2p send fail', e); }
}

function handleP2PMessage(raw){
  let msg = null;
  try { msg = JSON.parse(raw); } catch(e){ return; }
  if(msg.type === 'deploy'){
    // remote deploy => spawn enemy troop mirrored
    spawnTroop('enemy', msg.cardIdx, LOGICAL_W*0.86 - 26 + rnd(-8,8), msg.y);
  } else if(msg.type === 'chat'){
    console.log('p2p chat', msg.text);
  }
}

// ---------- Game init / restart ----------
const restartBtnEl = document.getElementById('restartBtn');
restartBtnEl.addEventListener('click', startMatch);
document.getElementById('modeAi').addEventListener('click', ()=>{ state.mode='ai'; renderModeButtons(); startMatch(); });
document.getElementById('modeLocal').addEventListener('click', ()=>{ state.mode='local'; renderModeButtons(); startMatch(); });
document.getElementById('modeP2P').addEventListener('click', ()=>{ state.mode='p2p'; renderModeButtons(); startMatch(); });

createOfferBtn.addEventListener('click', async ()=>{ await createOffer(); });
acceptOfferBtn.addEventListener('click', async ()=>{ await acceptOffer(); });
acceptAnswerBtn.addEventListener('click', async ()=>{ await acceptAnswer(); });

function renderModeButtons(){
  document.getElementById('modeAi').style.opacity = state.mode==='ai' ? '1' : '0.75';
  document.getElementById('modeLocal').style.opacity = state.mode==='local' ? '1' : '0.75';
  document.getElementById('modeP2P').style.opacity = state.mode.startsWith('p2p') || state.mode==='p2p' ? '1' : '0.75';
}

function startMatch(){
  state.running = true;
  state.timeLeft = MATCH_TIME;
  state.elixir = 5;
  state.selectedCardIdx = null;
  state.entities = [];
  state.aiTimer = 1.4;
  state.result = null;
  buildHand();
  renderHand();
  resetTowers();
  updateUI();
  beep(700,0.06,0.03);
  // if switching into p2p mode, clear existing p2p state
  if(state.mode === 'p2p') state.mode = 'p2p-host';
}
startMatch();
renderModeButtons();

// ---------- game loop ----------
let last = performance.now();
function loop(ts){
  const dt = Math.min(0.06, (ts - last)/1000);
  last = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------- UI / helper for debugging exposure ----------
window.ArenaRushPlus = { state, spawnTroop, hand, CARD_POOL };
document.addEventListener('keydown', (e) => {
  if(e.key === 'd') state.debug = !state.debug;
  if(e.key === 'r') startMatch();
});

// ---------- initial layout sizing and logical mapping ----------
function initSizing(){
  // set the canvas CSS size to a 16:9-ish region (it will be resized on window resize)
  canvas.style.width = '100%';
  canvas.style.height = '640px';
  // ensure resize one time
  resizeCanvas();
}
initSizing();

</script>
</body>
</html>
